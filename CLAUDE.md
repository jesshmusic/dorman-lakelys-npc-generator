# CLAUDE.md - Technical Reference for AI Assistants

This document contains technical notes, patterns, and conventions for working on the Dorman Lakely's NPC Generator project.

> **Note**: This is the **developer documentation**. The README.md is written for end users and contains no implementation details. Keep them separate:
>
> - **README.md**: User-focused, benefits-oriented, no technical jargon
> - **CLAUDE.md**: Developer-focused, implementation details, code patterns

## Project Overview

**Dorman Lakely's NPC Generator** is a FoundryVTT v12 module that generates NPCs for D&D 5e with complete stat blocks, equipment, spells, and class features. Built with TypeScript, uses Foundry's ApplicationV2 API.

**Key Dependencies:**

- FoundryVTT v12+ (uses ApplicationV2 API)
- D&D 5e System (required for actor creation)
- dnd5e.items, dnd5e.spells, dnd5e.classfeatures, dnd5e.monsterfeatures compendiums

## Architecture

### File Structure

```
src/
├── main.ts                          # Module entry point, hooks
├── ui/
│   └── ExistentialNPCGeneratorUI.ts # ApplicationV2 dialog & UI logic
├── generator/
│   └── ExistentialNPCGenerator.ts   # Core NPC generation logic
├── utils/
│   ├── crCalculations.ts            # CR to stats calculations
│   ├── classData.ts                 # Class features and skills data
│   ├── equipmentData.ts             # Equipment pools by CR
│   └── spellData.ts                 # Spell selections by class/level
├── settings/
│   └── ModuleSettings.ts            # Module settings registration
└── types/
    └── foundry.d.ts                 # Foundry type definitions

templates/
└── npc-form.html                    # Handlebars template for NPC form

scripts/                             # Build output (generated by Vite)
```

### Build System

- **Vite** bundles TypeScript → ES modules at `scripts/main.js`
- **vite-plugin-dts** generates type definitions
- Scripts: `npm run build`, `npm run dev` (watch mode), `npm run clean`
- Release scripts: `npm run release:patch|minor|major`

## Foundry VTT v12 Patterns

### ApplicationV2 Dialogs

The NPC generator uses ApplicationV2 with HandlebarsApplicationMixin:

```typescript
const { ApplicationV2, HandlebarsApplicationMixin } = (foundry as any).applications.api;

class NPCGeneratorDialog extends HandlebarsApplicationMixin(ApplicationV2) {
  static DEFAULT_OPTIONS = {
    id: 'npc-generator-dialog',
    classes: ['dnd5e2', 'sheet', 'npc-generator'],
    tag: 'form',
    window: {
      title: 'NPC Generator',
      icon: 'fas fa-user-plus',
      resizable: true
    },
    position: {
      width: 520,
      height: 'auto' as const // Use 'as const' for literal types
    },
    actions: {
      create: NPCGeneratorDialog.onCreateNPC,
      cancel: NPCGeneratorDialog.onCancel
    }
  };

  static PARTS = {
    form: {
      template: 'modules/dorman-lakelys-npc-generator/templates/npc-form.html'
    }
  };

  async _prepareContext(_options: any): Promise<any> {
    // Get compendiums and folders, handle undefined gracefully
    const compendiums = game.packs
      ? Array.from(game.packs.values())
          .filter((pack: any) => pack.documentName === 'Actor' && !pack.locked)
          .map((pack: any) => ({
            id: pack.collection,
            title: pack.title
          }))
      : [];

    const folders = Array.from(game.folders?.values() || [])
      .filter((folder: any) => folder.type === 'Actor')
      .map((folder: any) => ({
        id: folder.id,
        name: folder.name
      }));

    return {
      species: NPCGenerator.SPECIES,
      alignments: NPCGenerator.ALIGNMENTS,
      challengeRatings: NPCGenerator.CHALLENGE_RATINGS,
      classes: NPCGenerator.CLASSES,
      compendiums,
      folders
    };
  }

  _onRender(context: any, options: any): void {
    super._onRender(context, options);
    // Set up event listeners for dynamic form behavior
  }

  static async onCreateNPC(event: Event, target: HTMLElement) {
    // Handle form submission
    const form = target.closest('form');
    const formData = new FormData(form);
    // Process and create NPC
  }
}
```

**Key Points:**

- Always check for `game.packs` and `game.folders` being undefined
- Use `as const` for literal type values like `'auto'`
- Prefix unused parameters with underscore: `_options`, `_event`
- Use `@ts-expect-error` instead of `@ts-ignore` with explanatory comments

### NPC Generation Flow

1. **User Input** → Dialog collects name, description, species, alignment, CR, class
2. **Stat Generation** → CR determines ability scores, HP, AC, saves, skills
3. **Equipment Selection** → CR-appropriate weapons and armor from equipment pools
4. **Feature Addition** → CR-based monster features (Keen Senses, Multiattack, etc.)
5. **Class Features** → Level-appropriate class features from compendium
6. **Spell Selection** → For spellcasting classes, appropriate spell levels
7. **Actor Creation** → Creates actor in world, folder, or compendium

### CR to Stats Calculations

Located in `src/utils/crCalculations.ts`:

```typescript
export interface CRStats {
  hp: number;
  ac: number;
  attackBonus: number;
  saveDC: number;
  proficiencyBonus: number;
}

export function parseCR(cr: string): number {
  // Converts "1/4", "1/2", "1", "2", etc. to numeric values
}

export function getCRStats(cr: number): CRStats {
  // Returns HP, AC, attack bonus, save DC for a given CR
}

export function crToLevel(cr: string): number {
  // Converts CR to equivalent character level for class features
}
```

### Equipment Pools

Equipment is organized by class and CR range in `src/utils/equipmentData.ts`:

```typescript
export interface EquipmentPool {
  weapons: string[];
  armor: string[];
}

export function getEquipmentForClass(className: string, cr: number): EquipmentPool {
  // Returns CR-appropriate weapons and armor for the class
  // Low CR: Simple weapons, light armor
  // Mid CR: Martial weapons, medium armor
  // High CR: +1 weapons, heavy armor
}
```

### Class Features & Spells

Class features are defined by level thresholds in `src/utils/classData.ts`:

```typescript
export const CLASS_FEATURES: Record<string, Record<string, string[]>> = {
  Fighter: {
    1: ['Fighting Style', 'Second Wind'],
    5: ['Extra Attack'],
    9: ['Indomitable'],
    11: ['Improved Extra Attack']
  }
  // ... other classes
};

export const CLASS_SKILLS: Record<string, string[]> = {
  Fighter: ['acr', 'ath', 'his', 'ins', 'itm', 'per']
  // ... other classes
};

export const SPELLCASTING_CLASSES = ['Cleric', 'Wizard', 'Druid', 'Bard', 'Sorcerer'];
```

Spell selection in `src/utils/spellData.ts`:

```typescript
export interface SpellSelection {
  cantrips: string[];
  level1: string[];
  level2: string[];
  // ... up to level9
}

export function getSpellsForClass(className: string, level: number): SpellSelection {
  // Returns appropriate spells based on class and level
  // Limits spell levels based on character level
}
```

## Compendium Integration

### Finding Items from D&D 5e Compendiums

```typescript
// Always check game.packs exists first
if (!game.packs) {
  console.warn('Game packs not available');
  return;
}

const pack = game.packs.get('dnd5e.items');
if (!pack) return;

// Search by name
const item = pack.index.find((i: any) => i.name === 'Longsword');
if (item) {
  const fullItem = await pack.getDocument(item._id);
}
```

### Creating Actors in Different Locations

**World:**

```typescript
const actorData = {
  name: npc.name,
  type: 'npc',
  folder: folderId, // Optional folder ID
  system: {
    /* ... actor data ... */
  }
};

const actor = await Actor.create(actorData);
```

**Compendium:**

```typescript
// Create in world first with all items
const actor = await this.createActorWithItems(npc);

// Import into compendium
const pack = game.packs.get(compendiumId);
const compendiumActor = await pack.importDocument(actor);

// Clean up temporary world actor
await actor.delete();

// Import back to world for viewing
const worldActor = await game.actors?.importFromCompendium(pack as any, compendiumActor.id);
worldActor.sheet?.render(true);
```

**Note:** Use `as any` for compendium pack types due to strict type narrowing issues.

## Actor Data Structure

### D&D 5e NPC Actor

```typescript
const actorData = {
  name: 'NPC Name',
  type: 'npc',
  folder: folderId || null,
  system: {
    abilities: {
      str: { value: 10, proficient: 0 },
      dex: { value: 10, proficient: 0 }
      // ... other abilities
    },
    attributes: {
      hp: { value: 30, max: 30 },
      ac: { calc: 'default' }, // Uses equipped armor
      movement: {
        walk: 30,
        fly: 0,
        climb: 0,
        swim: 0,
        units: 'ft'
      }
    },
    details: {
      cr: '1',
      type: { value: 'humanoid' },
      alignment: 'neutral',
      biography: { value: '<p>Biography HTML</p>' }
    },
    skills: {
      ath: { value: 1, ability: 'str' } // 1 = proficient
      // ... other skills
    },
    traits: {
      languages: {
        value: new Set(['common', 'elvish']),
        custom: ''
      }
    },
    currency: { cp: 0, sp: 0, ep: 0, gp: 0, pp: 0 }
  },
  prototypeToken: {
    name: 'NPC Name'
  }
};
```

### Adding Items to Actor

```typescript
// Equipment, features, and spells are all "Item" documents
await actor.createEmbeddedDocuments('Item', [itemData1, itemData2]);

// Mark equipment as equipped
const itemData = items.map((i: any) => {
  const obj = i.toObject();
  if (obj.system && 'equipped' in obj.system) {
    obj.system.equipped = true;
  }
  return obj;
});
```

## TypeScript & Build Configuration

### tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ES2022",
    "moduleResolution": "bundler", // Important for v12 types
    "lib": ["ES2022", "DOM"],
    "types": ["@league-of-foundry-developers/foundry-vtt-types"],
    "outDir": "./scripts",
    "rootDir": "./src",
    "strict": true,
    "skipLibCheck": true
  }
}
```

**Key Settings:**

- `moduleResolution: "bundler"` - Required for Foundry v12 types
- `types: ["@league-of-foundry-developers/foundry-vtt-types"]` - Provides global types
- Remove `"jsx": "react-jsx"` - Not needed, we use Handlebars

### Common Type Issues & Solutions

**1. Undefined Safety:**

```typescript
// Always check for undefined
if (!game.packs) return;
if (!game.settings) return;
```

**2. Type Assertions:**

```typescript
// Use 'as any' for complex Foundry types that don't narrow properly
const pack = game.packs.get(id) as any;
await game.actors?.importFromCompendium(pack as any, actorId);
```

**3. Literal Types:**

```typescript
// Use 'as const' for literal string types
position: {
  width: 520,
  height: 'auto' as const // Not just string
}
```

**4. Unused Variables:**

```typescript
// Prefix with underscore
async _prepareContext(_options: any): Promise<any> {}
static async onCancel(_event: Event, _target: HTMLElement) {}
```

## Linting & Formatting

### ESLint Configuration

Uses flat config (`eslint.config.mjs`) with TypeScript support:

```javascript
export default [
  {
    ignores: ['scripts/**', 'node_modules/**', '*.js', '*.mjs']
  },
  {
    files: ['src/**/*.ts'],
    languageOptions: {
      parser: tsParser,
      parserOptions: {
        ecmaVersion: 2022,
        sourceType: 'module',
        project: './tsconfig.json'
      }
    },
    plugins: {
      '@typescript-eslint': tseslint,
      prettier: prettier
    },
    rules: {
      ...tseslint.configs.recommended.rules,
      'prettier/prettier': 'warn',
      '@typescript-eslint/no-explicit-any': 'off', // Foundry APIs use 'any'
      '@typescript-eslint/no-unused-vars': [
        'warn',
        {
          argsIgnorePattern: '^_', // Allow _unused
          varsIgnorePattern: '^_'
        }
      ]
    }
  }
];
```

### Prettier Configuration

`.prettierrc`:

```json
{
  "semi": true,
  "trailingComma": "none",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false,
  "arrowParens": "avoid",
  "endOfLine": "lf"
}
```

### Running Linting

```bash
npm run lint          # Check for issues
npm run lint:fix      # Auto-fix issues
npm run format        # Format all code
npm run format:check  # Check formatting
```

**Before committing:**

```bash
npm run lint:fix && npm run format && npm run build
```

## Handlebars Templates

### Form Structure

```html
<form>
  <div class="form-group">
    <label for="name">{{localize "EMPUZZLES.Name"}}</label>
    <input type="text" name="name" value="{{name}}" required />
  </div>

  <div class="form-group">
    <label for="species">{{localize "EMPUZZLES.Species"}}</label>
    <select name="species">
      {{#each species as |s|}}
      <option value="{{s}}">{{s}}</option>
      {{/each}}
    </select>
  </div>

  <div class="form-group">
    <label for="destination">{{localize "EMPUZZLES.Destination"}}</label>
    <select name="destination" id="npc-destination">
      <option value="world">{{localize "EMPUZZLES.World"}}</option>
      <option value="new-compendium">{{localize "EMPUZZLES.NewCompendium"}}</option>
      {{#each compendiums as |comp|}}
      <option value="compendium:{{comp.id}}">{{comp.title}}</option>
      {{/each}}
    </select>
  </div>

  <button type="submit" data-action="create">
    <i class="fas fa-check"></i>
    {{localize "EMPUZZLES.Create"}}
  </button>
</form>
```

### Localization

All user-facing strings in `lang/en.json`:

```json
{
  "EMPUZZLES": {
    "NPCGenerator": "NPC Generator",
    "Name": "Name",
    "NameHint": "The name of the NPC",
    "Species": "Species",
    "Alignment": "Alignment"
  }
}
```

Access in code: `game.i18n.localize('EMPUZZLES.NPCGenerator')`

## Settings Management

### Registering Settings

In `main.ts`:

```typescript
game.settings.register('dorman-lakelys-npc-generator', 'settingName', {
  name: 'Display Name',
  hint: 'Help text',
  scope: 'world', // or 'client'
  config: true, // Show in module settings
  type: String,
  default: 'default value',
  requiresReload: true // Prompts reload when changed
});
```

### Accessing Settings

```typescript
const value = game.settings.get('dorman-lakelys-npc-generator', 'settingName') as string;
await game.settings.set('dorman-lakelys-npc-generator', 'settingName', newValue);
```

## CR Calculator Integration

This module has optional integration with the CR Calculator module (`fvtt-challenge-calculator`). When installed, the CR Calculator automatically validates generated NPCs and optionally adjusts their CR based on actual stats, abilities, and equipment.

### Detecting CR Calculator Availability

Before using the CR Calculator API, check if it's installed and active:

```typescript
const crCalcModule = game.modules?.get('fvtt-challenge-calculator');
const crCalcAPI = crCalcModule?.active ? crCalcModule.api : null;

if (crCalcAPI) {
  // CR Calculator is available - use the API
} else {
  // CR Calculator not available - fall back to default behavior
}
```

### CR Calculator API

The CR Calculator exposes a public API with the following interface:

```typescript
interface CRCalculatorAPI {
  // Calculate CR for an actor and optionally update the actor's CR
  calculateCRForActor(actor: Actor, updateActor: boolean): Promise<CRCalculationResult>;

  // Array of all challenge rating definitions
  challengeRatings: ChallengeRating[];

  // Database of all monster features by name
  monsterFeatures: Record<string, MonsterFeature>;

  // Array of all monster feature names
  monsterFeatureNames: string[];
}

interface CRCalculationResult {
  calculatedCR: number; // Final calculated CR
  defensiveCR: number; // CR based on HP, AC, and defensive abilities
  offensiveCR: number; // CR based on DPR and attack bonus
  // ... additional calculation details
}
```

### Post-Creation CR Validation Flow

After creating an NPC actor, the integration follows this flow:

1. **Calculate Actual CR**: Calls `calculateCRForActor(actor, false)` to get the calculated CR without updating the actor
2. **Compare CRs**: Compares calculated CR to the target CR that was requested
3. **Handle Difference**:
   - **Significant difference (>1 CR)**: Shows `CRComparisonDialog` to let user choose which CR to use
   - **Small difference (≤1 CR)**: Auto-updates to calculated CR with notification
   - **No difference**: Proceeds normally
4. **Graceful Fallback**: If CR Calculator is unavailable or errors occur, continues with target CR

### Using CR Comparison Dialog

The `CRComparisonDialog` is a Promise-based dialog that lets users choose between target and calculated CR:

```typescript
const choice = await CRComparisonDialog.show(
  targetCR, // The CR that was requested
  calculatedCR, // The CR based on actual stats
  defensiveCR, // Defensive CR component
  offensiveCR, // Offensive CR component
  actorName // Name of the NPC for display
);

if (choice === 'calculated') {
  // User chose to use the calculated CR
  await actor.update({ 'system.details.cr': calculatedCR });
  ui.notifications?.info(`Updated to calculated CR ${calculatedCR}`);
} else if (choice === 'target') {
  // User chose to keep the target CR
  ui.notifications?.info(`Kept target CR ${targetCR}`);
} else {
  // User cancelled (choice is null)
  // Keep original CR without notification
}
```

### Example: Complete CR Validation Implementation

This example from `ExistentialNPCGeneratorUI.ts` shows the complete validation flow:

```typescript
if (actor) {
  // Check if CR Calculator is available
  const crCalcModule = game.modules?.get('fvtt-challenge-calculator');
  const crCalcAPI = crCalcModule?.active ? crCalcModule.api : null;

  if (crCalcAPI) {
    try {
      // Calculate actual CR using CR Calculator
      const result = await crCalcAPI.calculateCRForActor(actor, false);
      const targetCR = parseCR(npc.challengeRating);
      const crDifference = Math.abs(result.calculatedCR - targetCR);

      if (crDifference > 1) {
        // Significant difference - let user choose
        const choice = await CRComparisonDialog.show(
          targetCR,
          result.calculatedCR,
          result.defensiveCR,
          result.offensiveCR,
          npc.name
        );

        if (choice === 'calculated') {
          await actor.update({ 'system.details.cr': result.calculatedCR });
          ui.notifications?.info(
            `Created ${npc.name} with calculated CR ${result.calculatedCR} (was ${targetCR})`
          );
        } else if (choice === 'target') {
          ui.notifications?.info(`Created ${npc.name} with target CR ${targetCR}`);
        }
      } else if (crDifference > 0) {
        // Small difference - auto-update
        await actor.update({ 'system.details.cr': result.calculatedCR });
        ui.notifications?.info(
          `Created ${npc.name}: CR adjusted ${targetCR} → ${result.calculatedCR}`
        );
      } else {
        // No difference
        ui.notifications?.info(`Created NPC: ${npc.name} (CR ${npc.challengeRating})`);
      }
    } catch (error) {
      // Error during calculation - fall back to target CR
      console.warn('Failed to validate CR with CR Calculator:', error);
      ui.notifications?.info(`Created NPC: ${npc.name} (CR ${npc.challengeRating})`);
    }
  } else {
    // CR Calculator not available
    ui.notifications?.info(`Created NPC: ${npc.name} (CR ${npc.challengeRating})`);
  }

  actor.sheet?.render(true);
}
```

### Future Enhancement: Monster Feature Selection

A planned Phase 2 enhancement will use the CR Calculator's `monsterFeatures` database to automatically add CR-appropriate monster features during NPC generation. This will leverage the weighted feature selection system to ensure NPCs have abilities that match their challenge rating.

## Common Patterns

### Safe Compendium Access

```typescript
private static async getItemsFromCompendium(
  packName: string,
  itemNames: string[]
): Promise<any[]> {
  try {
    if (!game.packs) {
      console.warn('Game packs not available');
      return [];
    }

    const pack = game.packs.get(packName);
    if (!pack) {
      console.warn(`Pack ${packName} not found`);
      return [];
    }

    const items = [];
    for (const itemName of itemNames) {
      const item = pack.index.find((i: any) => i.name === itemName);
      if (item) {
        const fullItem = await pack.getDocument(item._id);
        if (fullItem) items.push(fullItem);
      }
    }

    return items;
  } catch (error) {
    console.warn(`Could not load items from ${packName}:`, error);
    return [];
  }
}
```

### Ability Score Modifiers

```typescript
export function getAbilityModifier(score: number): number {
  return Math.floor((score - 10) / 2);
}
```

### Skill Keys

D&D 5e uses 3-letter skill abbreviations:

```typescript
const skillMap: Record<string, string> = {
  acr: 'dex', // Acrobatics
  ani: 'wis', // Animal Handling
  arc: 'int', // Arcana
  ath: 'str', // Athletics
  dec: 'cha', // Deception
  his: 'int', // History
  ins: 'wis', // Insight
  itm: 'cha', // Intimidation
  inv: 'int', // Investigation
  med: 'wis', // Medicine
  nat: 'int', // Nature
  prc: 'wis', // Perception
  prf: 'cha', // Performance
  per: 'cha', // Persuasion
  rel: 'int', // Religion
  slt: 'dex', // Sleight of Hand
  ste: 'dex', // Stealth
  sur: 'wis' // Survival
};
```

## Testing & Development

### Development Workflow

1. Run `npm run dev` for watch mode
2. Make changes in `src/`
3. Refresh Foundry (F5)
4. Test NPC generation with different CRs and classes
5. Check created actors have correct stats, equipment, features, spells

### Console Debugging

```typescript
console.log('NPC Data:', npc);
console.table(npc.abilities);
```

## Common Gotchas

1. **Always check `game.packs` and `game.settings` for undefined**
2. **Use `as any` for strict compendium type issues**
3. **Use `as const` for literal type values in DEFAULT_OPTIONS**
4. **Prefix unused parameters with underscore**
5. **Use `@ts-expect-error` instead of `@ts-ignore` with explanatory comments**
6. **CompendiumCollection.createCompendium() signature differs from types - use `as any`**
7. **Always equip items after adding them to actor**
8. **CR fractions ("1/4") must be parsed to numbers for calculations**
9. **Spell level availability depends on character level, not just class**
10. **Actor creation must happen before adding embedded items**

## Version Management

Uses custom release scripts (`scripts/release.js`):

```bash
npm run release:patch  # 1.0.0 → 1.0.1
npm run release:minor  # 1.0.0 → 1.1.0
npm run release:major  # 1.0.0 → 2.0.0
```

Updates `package.json`, `module.json`, and generates `CHANGELOG.md` from git commits.

## Best Practices

1. **Always run linting and formatting before committing**
2. **Test with multiple CRs (1/4, 1, 5, 10, 20) to ensure stats scale properly**
3. **Test all three destination types: world, folder, compendium**
4. **Verify equipment is equipped and functional**
5. **Check that spell levels match character level**
6. **Ensure class features appear at correct levels**
7. **Document any new equipment pools or spell selections**
8. **Use descriptive variable names for CR-based calculations**
9. **Keep utility functions pure (no side effects)**
10. **Handle missing compendiums gracefully with warnings**
